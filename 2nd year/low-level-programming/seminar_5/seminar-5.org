#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+LANGUAGE: ru
#+OPTIONS: ':t
#+OPTIONS: toc:3
#+OPTIONS: tasks:nil

#+TITLE: Семинар 5: Цикл компиляции

  

  Как мы узнали из лекций, чтобы успешно создать и развивать хоть сколько-нибудь
  большую систему необходимо следовать двум принципам:

  - делить систему на части-модули;
  - абстрагировать эти модули, то есть максимально скрывать их внутреннее устройство.

  Исходный код программы после трансляции в машинные инструкции и запуска
  приложения "встраивается" в вычислительную систему. Когда программа написана в
  одном большом файле, при её запуске в вычислительную систему добавляется большой
  модуля, который сложно изучать и отлаживать. Если же разделить исходный код на
  файлы, то запуск программы можно мысленно воспринимать как внесение в систему
  нескольких модулей поменьше. Это существенно облегчает труд разработчиков
  системы.

  В этом семинаре мы глубже познакомимся с тем, как программа из исходного кода
  становится исполняемым файлом.
* Цикл компиляции (5 минут)


  Исходный код преобразуется в набор машинных инструкций, которые можно выполнить на процессоре, в несколько больших этапов (каждый из них может состоять из многих меньших этапов):

  - Препроцессинг ::  преобразование текстового файла на ассемблере с директивами макропроцессора в текстовый файл на ассемблере уже без этих директив. Этим занимается *препроцессор* — отдельная программа или часть компилятора.
  - Трансляция :: преобразование текстового файла на ассемблере в объектный файл. Этим занимается сам **компилятор** Объектный файл содержит инструкции, но адреса в них не проставлены.
  - Компоновка (линковка) :: специальная программа *компоновщик* собирает исполняемый файл с инструкциями изо всех объектных файлов.

  В прошлых семинарах чтобы скомпилировать программу на ассемблере =hello.asm= мы
  выполняли следующие команды, не раскрывая их смысл:

  #+BEGIN_SRC sh
    nasm -f elf64 -o hello.o hello.asm
    ld -o hello hello.o
  #+END_SRC

  - В первой строчке запускается программа =nasm=, осуществляющая и /препроцессинг/ исходного кода и его /компиляцию/.

    #+BEGIN_SRC sh
      nasm -f elf64 -o hello.o hello.asm
    #+END_SRC

  - Во второй строчке запускается /компоновщик/, который делает из объектных файлов исполняемые.

    #+BEGIN_SRC sh
      ld -o hello hello.o
    #+END_SRC


  Если программа содержит несколько файлов, то каждый из них проходит
  препроцессинг и компиляцию отдельно от остальных. Затем все объектные файлы
  мы передаем компоновщику. Полная компиляция для трёх ассемблерных файлов =a.asm= =b.asm=
  =c.asm= будет выглядеть так:

  #+BEGIN_SRC sh
    nasm -f elf64 -o a.o a.asm
    nasm -f elf64 -o b.o b.asm
    nasm -f elf64 -o c.o c.asm
    ld -o program a.o b.o c.o
  #+END_SRC
** Препроцессинг (15 минут)

   Препроцессинг производит в файле текстовые замены, описанные специальными командами. Это подготавливает программу к компиляции и позволяет полуавтоматически генерировать рутинный код, который иначе пришлось бы писать самостоятельно. Например, =%define= определяет замену одной строчки на другую:

   #+BEGIN_SRC asm
       ; После этой строчки символ `x` везде будет заменён на строчку "Hello"
       %define x "Hello"
     
     
       ; Пример использования:
       db x 
       db x 
       db x 
   #+END_SRC

   Фактически препроцессор из программы на языке "ассемблер + команды управления препроцессором" делает программу на языке ассемблера, готовую для компиляции.

   Чтобы остановить процесс сразу после препроцессора и посмотреть на изменённый код программы,  запустите =nasm= с ключом =-E=.

   *Задание 1* проведите следующий код через препроцессор и изучите результат.

   #+BEGIN_SRC asm
       ; После этой строчки символ `x` везде будет заменён на строчку "Hello"
       %define x "Hello"
     
     
       ; Пример использования:
       db x 
       db x 
       db x 
   #+END_SRC
   
   /Чтобы выполнить ввожу команду:/ =nasm -e script_name.asm=
   /Результат выполнения/:
    #+BEGIN_SRC asm
    %line 1+1 task1.asm
    db Hello
    db Hello
    db Hello
    #+END_SRC
----------------------------------------------------------------------------------------------------------------------------

   *Задание 2* проведите следующий код через препроцессор и изучите результат   

   #+BEGIN_SRC asm
       %define i 1
     
       %define d i * 3
     
       mov rax, d
     
       ; let's redefine i
       %define i 100
       mov rax, d
   #+END_SRC
   
   /Результат выполнения/:
    #+BEGIN_SRC asm
    %line 2+1 task2.asm
    
    mov rax, 1 * 3
    mov rax, 100 * 3
    #+END_SRC
----------------------------------------------------------------------------------------------------------------------------

   *Задание 3* проведите следующий код через препроцессор и изучите результат. Что такое =x=? Скомпилируется ли эта программа?
 
   #+BEGIN_SRC asm
       %define process(x) (x * 3 + 23)
     
       mov rax,  process( 9 )
     
   #+END_SRC
   
    /Результат выполнения/:
    #+BEGIN_SRC asm
    %line 2+1 task3.asm

    mov rax, (rcx * 3 + 23)
    #+END_SRC
    
    /Программа не скомпилируется, потому что на ассемблере писать/ =(rcx * 3 + 23)= /нельзя./ 
    /А/ =x= /это похоже воспринимается как параметр функции. Т.е. когда мы говорим/ =%define process(x) (x * 3 + 23)= /мы обозначаем функцию/ =process(x)=, /как выражение/ =(x * 3 + 23)=, /а/ =x= /как и было везде параметром так и остаётся./ 
----------------------------------------------------------------------------------------------------------------------------

   *Задание 4* проведите следующий код через препроцессор и изучите результат. Скомпилируется ли эта программа?

   #+BEGIN_SRC asm
       %define process(x) (x * 3 + 23)
     
       mov rax,  process( rcx )
     
   #+END_SRC
   
   /Результат выполнения/:
    #+BEGIN_SRC asm
    %line 2+1 task4.asm

    mov rax, (rcx * 3 + 23)
    #+END_SRC
    
    /Программа не скомпилируется, потому что на ассемблере писать/ =(rcx * 3 + 23)= /нельзя./
----------------------------------------------------------------------------------------------------------------------------
 
   *Задание 5* проведите следующий код через препроцессор и изучите результат. Что означает 3 после имени макроса =test=? Прочитайте секцию 4.3 [[https://www.tortall.net/projects/yasm/manual/html/nasm-multi-line-macros.html][документации nasm]].
 
   #+BEGIN_SRC asm
       %macro test 3
       db %1
       db %2 
       db %3
       %endmacro
       test "hello", ",", " world"
   #+END_SRC
   
   /Результат выполнения/:
    #+BEGIN_SRC asm
   %line 6+1 task5.asm

   test hello, ,, world
   #+END_SRC
   /Цифра три поле макроса -- количество параетров, которые макрос ожидает на вход. По сути, вызов макроса потом заменяется на:/
    #+BEGIN_SRC asm
       push    ebp
        mov     ebp,esp
        sub     esp,12
   #+END_SRC
   /С помощью/ =%1= /или/ =%2= /можно ссылаться на параметры передаваемые макросу./
   /Пример работы макросов:/
   #+BEGIN_SRC asm
   %macro silly 2 
   %2:       db %1 
   %endmacro 
   
   silly 'a', letter_a    ; letter_a:  db 'a' 
   silly 'ab', string_ab  ; string_ab: db 'ab' 
   silly {13,10}, crlf    ; crlf:      db 13,10
   #+END_SRC
---------------------------------------------------------------------------------------------------------------------------

   *Задание 6* перепишите этот макрос так, чтобы он добавлял запятую между строчками текста, переданными ему.
    
    #+BEGIN_SRC asm
       %macro test 2
       db %1
       db ","
       db %2
       %endmacro
       test "hello", " world"
   #+END_SRC
   
   /Результат выполнения/:
   #+BEGIN_SRC asm
   %line 4+1 task6.asm
   db "hello"
   db ","
   db "world"
   #+END_SRC
---------------------------------------------------------------------------------------------------------------------------
** Компилятор (15 минут)

   Задача компилятора --- перевести исходный код в набор исполняемых инструкций. В случае с языком ассемблера, этот процесс достаточно прозрачен: каждой мнемонике ассемблера соответствует инструкция процессора.
   При необходимости детали кодирования команд можно посмотреть на страничках инструкций в [[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html][Intel® 64 and IA-32 Architectures Software Developer’s Manual]].


   Для программ из нескольких файлов-модулей, компилируемых в изоляции друг от друга, возникает необходимость явно описывать, какие внешние функции/данные нам нужны в каждом файле. Пусть файл =a.asm= содержит функции =f= и =h=; мы хотим использовать функцию =f= в файле =b.asm=. Тогда чтобы обеспечить взаимодействие между кодом из этих файлов:

   - То, что файл выставляет наружу другим модулям, мы отдельно декларируем как =global=.
   - То, что мы хотим импортировать из других файлов, в месте импорта декларируется как =extern=.

   #+BEGIN_SRC asm
       ; a.asm ; 
       global f
     
       ; h остаётся недоступной
     
       f: 
          код 
       h: 
          код 
   #+END_SRC

   #+BEGIN_SRC asm
       ; b.asm ;
       extern f
     
       ...
       call f ; работает
   #+END_SRC


   *Задание 7* в третьем семинаре вы работали с функцией =print_hex=. Создайте программу из двух файлов: один содержит функцию =print_hex=, в другом содержится метка =_start= и происходит вызов =print_hex=. Скомпилируйте их и запустите программу. Какие команды необходимы чтобы провести оба файла с кодом через весь цикл компиляции?

   #+BEGIN_SRC asm
section .data
codes:
    db      '0123456789ABCDEF'

section .text
global _start
_start:
       print_hex:
           mov rax, rdi
           mov rdi, 1
           mov rdx, 1
           mov rcx, 64
         ; Each 4 bits should be output as one hexadecimal digit
         ; Use shift and bitwise AND to isolate them
         ; the result is the offset in 'codes' array
       .loop:
           push rax
           sub rcx, 4
         ; cl is a register, smallest part of rcx
         ; rax -- eax -- ax -- ah + al
         ; rcx -- ecx -- cx -- ch + cl
           sar rax, cl
           and rax, 0xf
     
           lea rsi, [codes + rax]
           mov rax, 1
     
           ; syscall leaves rcx and r11 changed
           push rcx
           syscall
           pop rcx
     
           pop rax
         ; test can be used for the fastest 'is it a zero?' check
         ; see docs for 'test' command
           test rcx, rcx
           jnz .loop
           ret
   #+END_SRC
   
   /Решение:/
   
    #+BEGIN_SRC asm
    ;task7_part1.asm
    section .data
    codes: db '0123456789ABCDF'
    section .text
    global print_hex
    print_hex:
           mov rax, rdi
           mov rdi, 1
           mov rdx, 1
           mov rcx, 64
       .loop:
           push rax
           sub rcx, 4

           sar rax, cl
           and rax, 0xf

           lea rsi, [codes + rax]
           mov rax, 1

           push rcx
           syscall
           pop rcx

           pop rax
           test rcx, rcx
           jnz .loop
           ret
   #+END_SRC
   
   #+BEGIN_SRC asm
   ;task7_part2.asm
   extern print_hex
   section .text
   global _start
   _start: call print_hex
           call exit

   exit: mov     rax, 60
   xor     rdi, rdi
   syscall
   #+END_SRC
   
   /Чтобы это всё счастье выполнялось надо скомпилировать файлы по отдельности:/
   
   #+BEGIN_SRC sh
   nasm -f elf64 -o task7_part2.o task7_part1.asm
   nasm -f elf64 -o task7_part2.o task7_part2.asm
   ld -o task7 task7_part1.o task7_part2.o
   ./task7
   #+END_SRC
   
   /Результат выполнения/: =0000000000000000=
  
** Компоновщик

   Компоновщик работает с полуфабрикатами --- объектными файлами --- и собирает из
   них исполняемый файл. Следующая команда переводит объектный файл =hello.o= в исполняемый файл =hello=.

   #+BEGIN_SRC sh
     ld -o hello hello.o
   #+END_SRC

   В этом курсе мы работаем с объектными файлами формата ELF. Помимо инструкций
   они содержат множество мета-информации про программу, необходимой для её
   загрузки, выполнения или отладки, например:

   - Какие строчки исходной программы на языке высокого уровня соответствуют каким ассемблерным инструкциям?
   - Какие функции начинаются с каких адресов?
   - Где находятся глобальные переменные?
   - Какие данные изменяемые, а какие должны быть защищены от перезаписи?
   - По какому адресу программа загружается в память?

*** Таблица символов (30 минут)
    
    Информация про ассемблерные метки после компиляции аккумулируется в /таблице символов/ и становится частью ELF-файла.

    Компоновщик использует таблицу символов чтобы связывать обращения по адресам и определения меток. Например, рассмотрим программу:

    #+BEGIN_SRC asm
        global _start
        section .data
        message: db  'hello, world!', 10
      
        section .text
        _start:
            mov     rsi, message 
    #+END_SRC

    С помощью утилиты =nm= мы можем посмотреть содержание её таблицы символов; в ней только два символа  =message= и =_start=:

    #+BEGIN_SRC sh
      > nm symbols.o
      00000000000000000 T _start
      0000000000000000 d message
    #+END_SRC

    *Вопрос 8-1* Объясните значение второго столбца.

    *Вопрос 8-2* Мы будем изучать исполняемые и объектные файлы с помощью утилит
    =readelf=, =nm= и =objdump=. Разберитесь, как посмотреть таблицу символов в =.o=-файле
    с помощью всех трёх (=man= содержат нужную информацию). Каждый раз обращайте внимание, как помечаются 
    локальные и глобальные символы.

    Инструкции в объектном фа йле можно посмотреть так:

    #+BEGIN_SRC sh
      > objdump -M intel-mnemonic -d symbols.o
      symbols.o:     file format elf64-x86-64
      
      Disassembly of section .text:
      
      0000000000000000 <.text>:
      0:   48 be 00 00 00 00 00    mov  rsi,0x0
      7:   00 00 00 
      
    #+END_SRC

    Что тут происходит:

    - В файле всего одна инструкция =mov rsi, <операнд>=, где операнд занимает 8 байт.
    - Операнд должен быть адресом =message=, но до компоновки адреса не проставлены: мы не знаем, начиная с какого адреса программа будет загружаться в память, и в каком порядке будут загружены объектные файлы, поэтому и точного значения адреса =message= не знаем.
    - Адрес начала секции =.text= неизвестен, поэтому он тоже установлен в 0.
    
    /Так же это можно посмотреть дисассемблированный файл вот так:/
    
    /было/
    #+BEGIN_SRC asm
     section .text
     global _start
     _start: call exit

     exit: mov     rax, 60
     xor     rdi, rdi
     syscall
    #+END_SRC
    =readelf -a task8.o= /стало/
    #+BEGIN_SRC sh
           ELF Header:
        Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
        Class:                             ELF64
        Data:                              2's complement, little endian
        Version:                           1 (current)
        OS/ABI:                            UNIX - System V
        ABI Version:                       0
        Type:                              REL (Relocatable file)
        Machine:                           Advanced Micro Devices X86-64
        Version:                           0x1
        Entry point address:               0x0
        Start of program headers:          0 (bytes into file)
        Start of section headers:          64 (bytes into file)
        Flags:                             0x0
        Size of this header:               64 (bytes)
        Size of program headers:           0 (bytes)
        Number of program headers:         0
        Size of section headers:           64 (bytes)
        Number of section headers:         5
        Section header string table index: 2

      Section Headers:
        [Nr] Name              Type             Address           Offset
             Size              EntSize          Flags  Link  Info  Align
        [ 0]                   NULL             0000000000000000  00000000
             0000000000000000  0000000000000000           0     0     0
        [ 1] .text             PROGBITS         0000000000000000  00000180
             000000000000000f  0000000000000000  AX       0     0     16
        [ 2] .shstrtab         STRTAB           0000000000000000  00000190
             0000000000000021  0000000000000000           0     0     1
        [ 3] .symtab           SYMTAB           0000000000000000  000001c0
             0000000000000078  0000000000000018           4     4     8
        [ 4] .strtab           STRTAB           0000000000000000  00000240
             0000000000000017  0000000000000000           0     0     1
      Key to Flags:
        W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
        L (link order), O (extra OS processing required), G (group), T (TLS),
        C (compressed), x (unknown), o (OS specific), E (exclude),
        l (large), p (processor specific)

      There are no section groups in this file.

      There are no program headers in this file.

      There is no dynamic section in this file.

      There are no relocations in this file.

      The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.

      Symbol table '.symtab' contains 5 entries:
         Num:    Value          Size Type    Bind   Vis      Ndx Name
           0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
           1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS task8.asm
           2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
           3: 0000000000000005     0 NOTYPE  LOCAL  DEFAULT    1 exit
           4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 _start

      No version information found in this file.
    #+END_SRC

    В таблицу символов попадает и другая служебная информация, например,
    адреса начала секций. Исполняемые файлы тоже имеют формат ELF, только в них
    больше информации. Например, в отличие от =.o=-файлов, в исполняемых файлах
    вписаны адреса, по которым каждая ассемблерная секция будет загружена в память.

    *Вопрос 8-3* изучите таблицы символов в файлах из задания с функцией =print_hex=. Как =global= и =extern= влияют на содержимое таблиц символов?
    
    
    =task7_part1.o=
    #+BEGIN_SRC sh
    $ objdump -M intel-mnemonic -d task7_part1.o

    task7_part1.o:     file format elf64-x86-64
    Disassembly of section .text:

    0000000000000000 <print_hex>:
       0:   48 89 f8                mov    rax,rdi
       3:   bf 01 00 00 00          mov    edi,0x1
       8:   ba 01 00 00 00          mov    edx,0x1
       d:   b9 40 00 00 00          mov    ecx,0x40

    0000000000000012 <print_hex.loop>:
      12:   50                      push   rax
      13:   48 83 e9 04             sub    rcx,0x4
      17:   48 d3 f8                sar    rax,cl
      1a:   48 83 e0 0f             and    rax,0xf
      1e:   48 8d b0 00 00 00 00    lea    rsi,[rax+0x0]
      25:   b8 01 00 00 00          mov    eax,0x1
      2a:   51                      push   rcx
      2b:   0f 05                   syscall
      2d:   59                      pop    rcx
      2e:   58                      pop    rax
      2f:   48 85 c9                test   rcx,rcx
      32:   75 de                   jne    12 <print_hex.loop>
      34:   c3                      ret
    #+END_SRC
    
    =task7_part2.o=
    #+BEGIN_SRC sh
    $ objdump -M intel-mnemonic -d task7_part2.o

    task7_part2.o:     file format elf64-x86-64
    Disassembly of section .text:

    0000000000000000 <_start>:
       0:   e8 00 00 00 00          call   5 <_start+0x5>
       5:   e8 00 00 00 00          call   a <exit>

    000000000000000a <exit>:
       a:   b8 3c 00 00 00          mov    eax,0x3c
       f:   48 31 ff                xor    rdi,rdi
      12:   0f 05                   syscall
    #+END_SRC
    
    *Вопрос 8-4* для чего метка =_start= помечается как =global=?
    /Видимо, чтобы было понятно, откуда начинать исполнение программы. Мы же обозначили/ =_start= /как/ =global=.
    
    *Вопрос 8-5* могут ли несколько =.o=-файлов содержать метки с одинаковым именем?

*** Таблица релокаций
    
     Другая таблица, которая также присутствет в ELF-файлах, это таблица релокаций. Она показывает, где нужно "пропатчить" скомпилированный код чтобы вставить в инструкции адреса операндов на место заглушек-нулей.

     *Вопрос* Выполните следущие команды. Изучите поля =Offset=, =Sym.Value=, =Sym. Name + Addend= и поймите, чему они соответствуют в выводе дизассемблера от =objdump=.
     
    #+BEGIN_SRC sh
      > objdump -M intel-mnemonic -d symbols.o
      > readelf --relocs symbols.o
    #+END_SRC

* Описание интерфейсов

  Представим ситуацию, когда мы создали библиотеку =lib.asm=, в которой десять функций:

  #+BEGIN_SRC asm
      global f1
      global f2
      global f3
      ...
      global f10
  #+END_SRC

  Если мы хотим использовать эти функции в сотне других файлов, в каждом нужно будет прописать следующие строчки:

  #+BEGIN_SRC asm
      extern f1
      extern f2
      extern f3
      ...
      extern f10
  #+END_SRC

  В дальнейшем при разработке нам может захотеться расширить набор функций в =lib.asm=. Тогда придётся вносить изменения в каждый из сотни файлов.

** Заголовочные файлы (10 минут)
  Более продуктивный подход к разработке заключается в том, чтобы выделить описание того, что нужно импортировать из библиотеки =lib.asm= в специальный файл =lib.inc=:

  #+BEGIN_SRC asm
    ; содержимое lib.inc
    extern f1
    extern f2
    extern f3
    ...
    extern f10
  #+END_SRC

  Тогда с помощью директивы препроцессора =%include "lib.inc"= можно включить =lib.inc= "как есть" во все файлы, нуждающиеся в библиотечных функциях. Фактически этот файл частично описывает интерфейс взаимодействия с модулем =lib.asm= (полным описанием являются метки, помеченные =global= в самом файле =lib.asm=.

*Вопрос* создайте библиотеку =lib.asm= с двумя функциями: =print_hex= и =exit= для выхода из приложения. Напишите к ней заголовочный файл. Протестируйте её, запустив функцию из другого файла с меткой =_start=.

